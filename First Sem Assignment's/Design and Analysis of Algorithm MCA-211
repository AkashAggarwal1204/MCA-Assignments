Question 1. a) What are the desirable characteristics of an algorithm? Find the GCD of p = 144 and q = 55 using Euclid’s algorithm.

Answer. 1)Input specified : 
The input is the data to be transformed during the computation to produce the output.An algorithm should have 0 or 
more well-defined inputs.Input precision requires that you know what kind of data, how much and what form the data should be

2)Output specified : 
The output is the data resulting from the computation (your intended result). An algorithm should have 1 or more well-defined
outputs, and should match the desired output.Output precision also requires that you know what kind of data, how much and what form the output should 
be (or even if there will be any output at all!).

3)Definiteness : 
Algorithms must specify every step and the order the steps must be taken in the process.Definiteness means specifying the sequence of 
operations for turning input into output. Algorithm should be clear and unambiguous.Details of each step must be also be spelled out (including how to handle errors).
It should contain everything quantitative and not qualitative.

4)Effectiveness : 
For an algorithm to be effective, it means that all those steps that are required to get to output must be feasible with the available 
resources.It should not contain any unnecessary and redundant steps which could make an algorithm ineffective.

5)Finiteness :
The algorithm must stop, eventually.Stopping may mean that you get the expected output OR you get a response that no solution is possible. Algorithms must terminate
after a finite number of steps.An algorithm should not be infinite and always terminate after definite number of steps. 

There is no point in developing an algorithm which is infinite as it will be useless for us.

6)Independent :
An algorithm should have step-by-step directions, which should be independent of any programming code.It should be such that it could be run on any of the programming languages.
Thus,these are the characteristics that an algorithm should have for its fruitfulness.

--> Find the GCD of p = 144 and q = 55 using Euclid’s algorithm.

GCD of 144 and 55


144 > 55

a = bq + r (0≤r<b)

114  = 55 x 2 + 34
55 = 34 x 1 + 21
34 = 21 x 1 + 13
21 = 13 x 1 + 8
13 = 8 x 1 + 5 
8 = 5 x 1 + 3
5 = 3 x 1 + 2
3 = 2 x 1 + 1
2 = 1 x 1 + 1
1 = 1 x 1 + 0

Here, r = 0
Therefore, Divisor is the GCD
Hence, 1 is the greatest common divisor(GCD) of 144 & 55


--> Find the GCD of p = 144 and q = 55 using Java.

--> First approach

public class GCD {
	
	public static void main(String[] args) {
		int a = 144;
		int b = 55;
		int r;
		do {
			r = a%b;
			a = b;
			b = r;
		} while (r != 0);
		System.out.println(a);
		
		
	}

}

Output = 1


--> Second approach

public class GCD {
	
	 static int gcd(int a, int b)
	    {
	        if (a == 0)
	          return b;
	        if (b == 0)
	          return a;
	      
	        if (a == b)
	            return a;
	        if (a > b)
	            return gcd(a-b, b);
	        return gcd(a, b-a);
	    }
	
	public static void main(String[] args) {
		int p = 114;
		int q = 55;
		System.out.println(gcd(p,q));
	}
	

}

Output = 1



Question 1. b) Differentiate between Greedy Technique and Dynamic Programming approach of problem solving. Name few problems which are solved using these techniques

Answer.
Greedy approach :
A Greedy algorithm is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and 
immediate benefit. So the problems where choosing locally optimal also leads to a global solution are best fit for Greedy. For example, consider the Fractional 
Knapsack Problem. The local optimal strategy is to choose the item that has maximum value vs weight ratio. This strategy also leads to global optimal solution
because we allowed taking fractions of an item. 

 Dynamic programming :
 Dynamic programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize
 it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple
 optimization reduces time complexities from exponential to polynomial. For example, if we write a simple recursive solution for Fibonacci Numbers, we get exponential
 time complexity and if we optimize it by storing solutions of subproblems, time complexity reduces to linear. 
 
 
 Feature	                                                            Greedy method                                         	                                                                                          Dynamic programming
Feasibility	  In a greedy Algorithm, we make whatever choice seems best at the moment in the hope that it will lead to global optimal solution.            In Dynamic Programming we make decision at each step considering current problem and solution to previously solved sub problem to calculate optimal solution .
Optimality	  In Greedy Method, sometimes there is no such guarantee of getting Optimal Solution.	                                                       It is guaranteed that Dynamic Programming will generate an optimal solution as it generally considers all possible cases and then choose the best.
Recursion	  A greedy method follows the problem solving heuristic of making the locally optimal choice at each stage.                                    A Dynamic programming is an algorithmic technique which is usually based on a recurrent formula that uses some previously calculated states.
Memoization	  It is more efficient in terms of memory as it never look back or revise previous choices	                                               It requires dp table for memoization and it increases it’s memory complexity.
Time complexity	  Greedy methods are generally faster. For example, Dijkstra’s shortest path algorithm takes O(ELogV + VLogV) time.	                       Dynamic Programming is generally slower. For example, Bellman Ford algorithm takes O(VE) time.
Fashion	          The greedy method computes its solution by making its choices in a serial forward fashion, never looking back or revising previous choices.  Dynamic programming computes its solution bottom up or top down by synthesizing them from smaller optimal sub solutions.






Question 2. a) Prove that, for all positive integers n, 1 + 2 + 4 + ⋯ + 2! = 2!"# − 1

Answer.
Consider the given statement
P(n):1+2+4+...2ⁿ=2ⁿ⁺¹−1, for natural numbers n.
Step I We observe that P(0) is true.
P(2):1+2+4=8−1
7=7, which is true.
Step II Now, assume that P(n) is true for n=k.
So, P(k) : 1+2+4+...2ᵏ=2ᵏ⁺¹−1 is true.
Step III Now, to prove P(k+1) is true.
P(k+1):1+2+4+...+2ᵏ+2ᵏ⁺¹
=2ᵏ⁺¹−1+2ᵏ⁺¹
=2⋅2ᵏ⁺¹−1
=2ᵏ⁺¹+1−1
So, P(k+1) is true, whenever P(k) is true.
Hence, P(n) is true.


Question 2. b) What are asymptotic notations? Explain the significance of Big- O, Omega and theta notations with suitable example.
Answer. Asymptotic notations are the mathematical notations used to describe the running time of an algorithm when the input tends towards 
a particular value ora limiting value.

For example: 
In bubble sort, when the input array is already sorted, the time taken by the algorithm is linear i.e. the best case.
But, when the input array is in reverse condition, the algorithm takes the maximum time (quadratic) to sort the elements i.e. the worst case.
When the input array is neither sorted nor in reverse order, then it takes average time. These durations are denoted using asymptotic notations.
There are mainly three asymptotic notations:

Big-O notation
Omega notation
Theta notation

Big-O Notation (O-notation)
Big-O notation represents the upper bound of the running time of an algorithm. Thus, it gives the worst-case complexity of an algorithm.

https://cdn.programiz.com/sites/tutorial2program/files/big0.png

O(g(n)) = { f(n): there exist positive constants c and n0
            such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }
The above expression can be described as a function f(n) belongs to the set O(g(n)) if there exists a positive constant c such that it lies between 0 and cg(n),
for sufficiently large n. For any value of n, the running time of an algorithm does not cross the time provided by O(g(n)).
Since it gives the worst-case running time of an algorithm, it is widely used to analyze an algorithm as we are always interested in the worst-case scenario.


Omega Notation (Ω-notation)
Omega notation represents the lower bound of the running time of an algorithm. Thus, it provides the best case complexity of an algorithm.

https://cdn.programiz.com/sites/tutorial2program/files/omega.png

Ω(g(n)) = { f(n): there exist positive constants c and n0 
            such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }
The above expression can be described as a function f(n) belongs to the set Ω(g(n)) if there exists a positive constant c such that it lies above cg(n), 
for sufficiently large n. For any value of n, the minimum time required by the algorithm is given by Omega Ω(g(n)).

Theta Notation (Θ-notation)
Theta notation encloses the function from above and below. Since it represents the upper and the lower bound of the running time of an algorithm,
it is used for analyzing the average-case complexity of an algorithm.

https://cdn.programiz.com/sites/tutorial2program/files/theta.png

For a function g(n), Θ(g(n)) is given by the relation:

Θ(g(n)) = { f(n): there exist positive constants c1, c2 and n0
            such that 0 ≤ c1g(n) ≤ f(n) ≤ c2g(n) for all n ≥ n0 }
The above expression can be described as a function f(n) belongs to the set Θ(g(n)) if there exist positive constants c1 and c2 such that it can be
sandwiched between c1g(n) and c2g(n), for sufficiently large n. If a function f(n) lies anywhere in between c1g(n) and c2g(n) for all n ≥ n0, then f(n) is 
said to be asymptotically tight bound.

Question 3. a) Evaluate p(x)= 3ˣ⁴+2ˣ³-5ˣ+7 at x=2 using Horne’s rule. Show step wise iterations.

Since the polynomial is of the 4th degree, then n = 4


K	   4	              3	                    1         	       0
Step	b4 = 3        	b3 = 2 + 2 * 3	     b1 = -5 + 2 * 8	b0 = 7 + 2 * 11
Result	   3	              8	                    11	               29


Question 3. b) Sort the given sequence of numbers using Bubble sort. Write all the steps involved. 13, 15, 2, 6, 14, 10, 8, 7, 3, 5, 19, 4.

Answer.
public class BubbleSorting {
	
	public static void main (String[] args)
	{
		int[] arr = {13, 15, 2, 6, 14, 10, 8, 7, 3, 5, 19, 4};
		int[] ar = sort(arr);
		for(int a:ar) {
			System.out.print(a+",");
		}
	}

	private static int[] sort(int[] arr) {
		int n = arr.length;
		for(int i=0;i<n-1;i++) {
			for(int j=0;j<n-i-1;j++) {
				if(arr[j] > arr[j+1]) {
					int temp = arr[j];
					arr[j] = arr[j+1];
					 arr[j+1] = temp; 
				}
			}
			for(int s:arr)
				System.out.print(s+",");
				System.out.println();
		}
		return arr;
	}
}


Output. After Bubble Sorting 2,3,4,5,6,7,8,10,13,14,15,19

Is's iterate from start to end for each number and iterate array[before] > array[after] then replace to each other

Steps: [13],2,6,14,10,8,7,3,5,15,4,19
2,6,[13],10,8,7,3,5,14,4,15,19
2,6,[10],8,7,3,5,[13],4,14,15,19
2,6,8,7,3,5,10,4,[13],[14],15,19
2,6,7,3,5,8,4,10,13,[14],[15],19
2,[6],3,5,7,4,8,10,13,14,[15],[19]
2,3,5,[6],4,7,8,10,13,14,15,19
2,3,5,4,[6],[7],8,10,13,14,15,19
2,3,4,5,6,[7],[8],10,13,14,15,19
2,3,4,5,6,7,[8],[10],13,14,15,19
2,3,4,5,6,7,8,[10],[13],14,15,19
2,3,4,5,6,7,8,10,[13],[14],15,19

Question 4. a) Find an optimal solution for the knapsack instance n=6 and M=13, (p1, p2,…, p6)=(8, 5, 13, 7, 6, 15) (w1, w2,…, w6)=(3, 2, 4, 6, 2, 5)

Answer. 
Given: n=6 and M=13, (p1, p2,…, p6)=(8, 5, 13, 7, 6, 15) (w1, w2,…, w6)=(3, 2, 4, 6, 2, 5)

To prove: Optimal solution that gives maximum profit.
Proof:
Step 1: (To find profit/ weight ratio)
p1/w1 = 8/3 = 2.67
p2/w2 = 5/2 = 2.5
p3/w3 = 13/4 = 3.25
p4/w4 = 7/6 = 1.167
p5/w5 = 6/2 = 3
p6/w6 = 15/5 = 3

Step 2: (Arrange this profit/weight ratio in non-increasing order as n values) Since the highest profit/weight ratio is 3.25. That is p3/w3, so 1st value is 3. 
Second highest profit/weight ratio is 3. That is p5/w5, so 2nd value is 5. Similarly, calculate such n values and arrange them in non-increasing order.

Order = (3, 5, 6, 1, 2, 4)

Step 3: (To find optimal solution using m = 13 & n = 6)

Consider x3 = 1, profit = 13
Then consider x1 = 1, profit = 8
So weight uptil now = 4 + 3 = 7

Now x6 = 1, profit = 15
So total profit = 21 + 15 = 36
And weight uptil now = 7 + 5 = 12

Now x5 = 1, profit = 6
So total profit = 36 + 6 = 42
And weight uptil now = 12 + 2 = 14

Now x4 = 1, profit = 7
So total profit = 42 + 7 = 49
And weight uptil now = 14 + 6 = 20

Since m = 13 so we require only 2 units more. Therefore x2 = 2/3
So total profit = 49 + 8 x 2/3 = 49 + 3.33 = 52.3
And weight uptil now = 20 + 3 x 2/3 = 22
Thus, the optimal solution that gives maximum profit is,
(1, 2/3, 1, 0, 1, 1, 1)


Question 4. b) Write the Huffman code for the following set of frequencies of given symbols. A:1, B:1, K:2, D:3, F:5, G:8 , H:13, E:21.

Answer. Huffman coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters. The most frequent character gets the smallest code and the least frequent character gets the largest code.
The variable-length codes assigned to input characters are Prefix Codes, means the codes (bit sequences) are assigned in such a way that the code assigned to one character is not the prefix of code assigned to any other character. This is how Huffman Coding makes sure that there is no ambiguity when decoding the generated bitstream. 
Let us understand prefix codes with a counter example. Let there be four characters a, b, c and d, and their corresponding variable length codes be 00, 01, 0 and 1. This coding leads to ambiguity because code assigned to c is the prefix of codes assigned to a and b. If the compressed bit stream is 0001, the de-compressed output may be “cccd” or “ccb” or “acd” or “ab”.
See this for applications of Huffman Coding. 
There are mainly two major parts in Huffman Coding

Build a Huffman Tree from input characters.
Traverse the Huffman Tree and assign codes to characters.

1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)
2. Extract two nodes with the minimum frequency from the min heap.
 
3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.
4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.
Let us understand the algorithm with an example:


character   Frequency
A             1
B	      1
K	      2
D	      3	
F             5
G             8
H             13
E             21

Step 1. Build a min heap that contains 6 nodes where each node represents root of a tree with single node.
Step 2 Extract two minimum frequency nodes from min heap. Add a new internal node with frequency 1 + 1 = 2. 

        2
       /\
      /  \
     /    \
    /      \
   /        \
  A:1       B:1   

Now min heap contains 7 nodes where 6 nodes are roots of trees with single element each, and one heap node is root of tree with 6 ements

character   Frequency
Internal Node  2
K	      2
D	      3	
F             5
G             8
H             13
E             21

Step 3: Extract two minimum frequency nodes from heap. Add a new internal node with frequency 2 + 2 = 4

        4
       /\
      /  \
     /    \
    /      \
   /        \
  K:2       IN:2   
             /\
            /  \
           /    \
          /      \
         /        \
        A:1       B:1  

Now min heap contains 6 nodes where 5 nodes are roots of trees with single element each, and one heap node is root of tree with 5 elements

character   Frequency
Internal Node  4
D	      3	
F             5
G             8
H             13
E             21

Step 4: Extract two minimum frequency nodes from heap. Add a new internal node with frequency 4 + 3 = 7

        7
       /\
      /  \
     /    \
    /      \
   /        \
  D:3       IN:4   
       	     /\
      	    /  \
           /    \
          /      \
         /        \
       K:2       IN:2   
                  /\
                 /  \
                /    \
               /      \
              /        \
             A:1       B:1  

Now min heap contains 5 nodes where 4 nodes are roots of trees with single element each, and one heap node is root of tree with 4 elements

character   Frequency
Internal Node  7
F             5
G             8
H             13
E             21

Step 5: Extract two minimum frequency nodes from heap. Add a new internal node with frequency 7 + 5 = 12

       12
       /\
      /  \
     /    \
    /      \
   /        \
  F:5       IN:7  
             /\
            /  \
           /    \
          /      \
         /        \
       D:3       IN:4   
       	          /\
      	         /  \
                /    \
               /      \
              /        \
            K:2       IN:2   
                       /\
                      /  \
                     /    \
                    /      \
                   /        \
                  A:1       B:1  

Now min heap contains 4 nodes where 3 nodes are roots of trees with single element each, and one heap node is root of tree with 3 elements

character   Frequency
Internal Node  12
G             8
H             13
E             21

Step 6: Extract two minimum frequency nodes from heap. Add a new internal node with frequency 12 + 8 = 20

       20
       /\
      /  \
     /    \
 G:8       IN:12  
            /\
           /  \
          /    \
         /      \
        /        \
       F:5       IN:7  
                  /\
                 /  \
                /    \
               /      \
              /        \
            D:3       IN:4   
            	          /\
           	         /  \
                        /    \
                       /      \
                      /        \
                    K:2       IN:2   
                               /\
                              /  \
                             /    \
                            /      \
                           /        \
                          A:1       B:1  

Now min heap contains 3 nodes where 2 nodes are roots of trees with single element each, and one heap node is root of tree with 2 elements

character   Frequency
Internal Node  20
H             13
E             21

Step 7:Extract two minimum frequency nodes from heap. Add a new internal node with frequency 20 + 13 = 33

       33
       /\
      /  \
     /    \
    /      \
   /        \
 H:13       IN:20  
             /\
            /  \
           /    \
        G:8     IN:12  
                  /\
                 /  \
                /    \
               /      \
              /        \
             F:5       IN:7  
                        /\
                       /  \
                      /    \
                     /      \
                    /        \
                  D:3       IN:4   
            	                /\
           	               /  \
                              /    \
                             /      \
                            /        \
                          K:2       IN:2   
                                     /\
                                    /  \
                                   /    \
                                  /      \
                                 /        \
                                A:1       B:1  

Now min heap contains 2 nodes where 1 nodes are roots of trees with single element each, and one heap node is root of tree with 1 elements

character   Frequency
Internal Node  33
E             21

Step 8:Extract two minimum frequency nodes from heap. Add a new internal node with frequency 33 + 21 = 54

       54
       /\
      /  \
     /    \
    /      \
   /        \
 E:21       IN:33  
              /\
             /  \
            /    \
           /      \
          /        \
        H:13       IN:20  
                    /\
                   /  \
                  /    \
               G:8     IN:12  
                         /\
                        /  \
                       /    \
                      /      \
                     /        \
                    F:5       IN:7  
                               /\
                              /  \
                             /    \
                            /      \
                           /        \
                         D:3       IN:4   
            	                       /\
           	                      /  \
                                     /    \
                                    /      \
                                   /        \
                                 K:2       IN:2   
                                            /\
                                           /  \
                                          /    \
                                         /      \
                                        /        \
                                       A:1       B:1  
   
    

Now min heap contains 1 odes where 1 nodes are roots of trees with single element each, and one heap node is root of tree with 1 elements

character   Frequency
Internal Node  54

Steps to print codes from Huffman Tree:
Traverse the tree formed starting from the root. Maintain an auxiliary array. While moving to the left child, write 0 to the array. While moving to the right child, write 1 to the array. Print the array when a leaf node is encountered.


						54
					        /\
					       /  \		
					      /    \
					    E:21   33	
					           /\
						  /  \
						 /    \
					       H:13   20
					       	      /\
						     /  \
						    /    \
						  G:8     12
						  	  /\
							 /  \
							/    \
						      F:5     7
						      	     /\
						            /  \
						           /    \
							 D:3     4
							        /\
							       /  \
							      /    \
							    K:2     2
							            /\
								   /  \
								  /    \
								 A:1   B:1

character   code-word
    E          0
    H          10
    G          110
    F          1110
    D          11110
    K          111110
    A          1111110
    B          1111111
    
    
    
Java Program

import java.util.PriorityQueue;
import java.util.Comparator;

class HuffmanNode {

	int data;
	char c;

	HuffmanNode left;
	HuffmanNode right;
}

class MyComparator implements Comparator<HuffmanNode> {
	public int compare(HuffmanNode x, HuffmanNode y)
	{
		return x.data - y.data;
	}
}

class Huffman {

	public static void printCode(HuffmanNode root, String s)
	{

		if (root.left == null && root.right == null && Character.isLetter(root.c)) {

			System.out.println(root.c + ":" + s);

			return;
		}

		printCode(root.left, s + "0");
		printCode(root.right, s + "1");
	}

	public static void main(String[] args)
	{

		int n = 8;
		char[] charArray = { 'a', 'b', 'k', 'd','f','g','h','e' };
		int[] charfreq = { 1, 1, 2, 3, 5, 8, 13, 21 };
		PriorityQueue<HuffmanNode> q
			= new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {
			HuffmanNode hn = new HuffmanNode();

			hn.c = charArray[i];
			hn.data = charfreq[i];

			hn.left = null;
			hn.right = null;
			q.add(hn);
		}

		HuffmanNode root = null;

		while (q.size() > 1) {

			HuffmanNode x = q.peek();
			q.poll();
			HuffmanNode y = q.peek();
			q.poll();

			HuffmanNode f = new HuffmanNode();

			f.data = x.data + y.data;
			f.c = '-';

			f.left = x;

			f.right = y;

			root = f;

			q.add(f);
		}

		printCode(root, "");
	}
}


Question 5. a) Write the steps involved in searching an element in a given array of sorted elements using Binary search algorithm. Assume the searched
element if not present in the sequence. 

Answer. An element in a sorted array can be found in O(log n) time via binary search. But suppose we rotate an ascending order sorted array at some pivot unknown to you beforehand. So for instance, 1 2 3 4 5 might become 3 4 5 1 2. Devise a way to find an element in the rotated array in O(log n) time

Time Complexity: O(log n). 
Binary Search requires log n comparisons to find the element. So time complexity is O(log n).
Space Complexity:O(1), No extra space is required.

Improved Solution: 
Approach: Instead of two or more pass of binary search the result can be found in one pass of binary search. The binary search needs to be modified to perform the search. The idea is to create a recursive function that takes l and r as range in input and the key.

public class BinarySearching {
	
	public static int BinarySearch(int[] arr,int min,int max,int key) {
		
		int mid = (min + max)/2;
		if(arr[mid] == key)
			return mid;
		if(arr[mid] > key) {
			return BinarySearch(arr, min, mid-1, key);
		}
		return BinarySearch(arr, mid+1, max, key);
	}

	public static void main(String[] args) {
		 int arr[] = { 4, 5, 6, 7, 8, 9, 1, 2, 3 };
		System.out.println(BinarySearch(arr, 0, arr.length-1, 8));
		

	}

}

Question 5. b) Analyse the merge sort algorithm Master Method. Also draw the relevant recursion tree.


Answer. 
Master Method Formulas
The master method is very straightforward. They call it a cookbook method. Just follow the recipe. It’s done!
There are three solutions for the standard form of the master method:
Case 1:
		O(nᵈlog(n)) if a = bᵈ
Case 2:
		O(nᵈ) if a < bᵈ
Case 3:
		O(nˡᵒᵍbᵃ) if a > bᵈ
		
Let’s solve the recurrence of merge sort:

This was the recurrence of the merge sort algorithm:

		T(n) = 2T(n/2)+O(n)

Comparing with the standard form of the Master method mentioned earlier, here, a = 2, b = 2, and d = 1.

		a = bᵈ is true.

So, Case 1 is the solution for the merge sort algorithm. So, the time complexity of the merge sort algorithm is O(nlog(n)).

Question 5. c) Explain divide and conquer strategy with an example of Matrix multiplication.

Answer. Matrix multiplication is an important operation in many mathematical and image processing applications. Suppose we want to multiply two matrices A and B, each of size n x n,  multiplication is operation is defined as

C11 = A11 B11 + A12 B21

C12 = A11 B12 + A12 B22

C21 = A21 B11 + A22 B21

C22 = A21 B12 + A22 B22

This approach is very costly as it required 8 multiplications and 4 additions.

Algorithm MATRIX_MULTIPLICATION(A, B, C)
// A and B are input matrices of size n x n
// C is the output matrix of size n x n

for i ← 1 to n do
  for j ← 1 to n do
    C[i][j] ← 0	
    for k ← 1 to n do
      C[i][j] ← C[i][j] + A[i][k]*B[k][j]
    end
  end
end


Question 6. a) Write the adjacency list and draw adjacency raph for the graph given
below.

Answer. Let us consider a graph in which there are N vertices numbered from 0 to N-1 and E number of edges in the form (i,j). Where (i,j) represent an edge originating from ith vertex and terminating on jth vertex. Now, A Adjacency Matrix is a N*N binary matrix in which value of [i,j]th cell is 1 if there exists an edge originating from ith vertex and terminating to jth vertex, otherwise the value is 0. Given below are Adjacency matrices for both Directed and Undirected graph shown above.


   /*
      This code is for constructing adjacency matrix for undirected graph, with minor change it will also work for directed graph.
   */
   #include <bits/stdc++.h>
   using namespace std;
   int main()
   {
       // where n is number of vertices and m is number of edges
   int n, u, v, m;
   cin>> n>> m;
   int A[n][n];
   for(int i=0; i&lt;n; i++)
   {
        for(int j=0; i&lt;n; j++)
            A[i][j]=0;
   } 
   for(int i=0; i&lt; m; i++)
   {
       cin>> u>> v;
       A[u][v]=1;
       A[v][u]=1; // In case of directed graph this statement is removed. 
   }
   // After above loop Adjcency matrix is ready.
    for(int i=0; i&lt;n; i++)
   {
        for(int j=0; j&lt;n; j++)
            cout&lt;&lt;A[i][j]&lt;&lt;" ";
        cout &lt;&lt; "\n";
   } 
   return 0;
 }


Question 6. b) Explain Topological sorting using a suitable example of a graph

Answer. Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.

For example, a topological sorting of the following graph is “5 4 2 3 1 0”. There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is “4 5 2 3 1 0”. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no incoming edges).

import java.io.*;
import java.util.*;
 
// This class represents a directed graph
// using adjacency list representation
class Graph {
    // No. of vertices
    private int V;
 
    // Adjacency List as ArrayList of ArrayList's
    private ArrayList<ArrayList<Integer> > adj;
 
    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new ArrayList<ArrayList<Integer> >(v);
        for (int i = 0; i < v; ++i)
            adj.add(new ArrayList<Integer>());
    }
 
    // Function to add an edge into the graph
    void addEdge(int v, int w) { adj.get(v).add(w); }
 
    // A recursive function used by topologicalSort
    void topologicalSortUtil(int v, boolean visited[],
                             Stack<Integer> stack)
    {
        // Mark the current node as visited.
        visited[v] = true;
        Integer i;
 
        // Recur for all the vertices adjacent
        // to thisvertex
        Iterator<Integer> it = adj.get(v).iterator();
        while (it.hasNext()) {
            i = it.next();
            if (!visited[i])
                topologicalSortUtil(i, visited, stack);
        }
 
        // Push current vertex to stack
        // which stores result
        stack.push(new Integer(v));
    }
 
    // The function to do Topological Sort.
    // It uses recursive topologicalSortUtil()
    void topologicalSort()
    {
        Stack<Integer> stack = new Stack<Integer>();
 
        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // Call the recursive helper
        // function to store
        // Topological Sort starting
        // from all vertices one by one
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                topologicalSortUtil(i, visited, stack);
 
        // Print contents of stack
        while (stack.empty() == false)
            System.out.print(stack.pop() + " ");
    }
 
    // Driver code
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g = new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);
 
        System.out.println("Following is a Topological "
                           + "sort of the given graph");
        // Function Call
        g.topologicalSort();
    }
}


Question 7. a) What is a minimum cost spanning tree? Explain the working of Kruskal’s Algorithm with example.

Answer. Kruskal’s algorithm is the concept that is introduced in the graph theory of discrete mathematics. It is used to discover the shortest path between two points in a connected weighted graph. This algorithm converts a given graph into the forest, considering each node as a separate tree. These trees can only link to each other if the edge connecting them has a low value and doesn’t generate a cycle in MST structure. In this tutorial, you will learn more about Kruskal Algorithm in detail.

Introduction to Kruskal Algorithm
As mentioned earlier, the Kruskal algorithm is used to generate a minimum spanning tree for a given graph. But, what exactly is a minimum spanning tree? A minimum spanning tree is a subset of a graph with the same number of vertices as the graph and edges equal to the number of vertices -1. It also has a minimal cost for the sum of all edge weights in a spanning tree.

Kruskal’s algorithm sorts all the edges in increasing order of their edge weights and keeps adding nodes to the tree only if the chosen edge does not form any cycle. Also, it picks the edge with a minimum cost at first and the edge with a maximum cost at last. Hence, you can say that the Kruskal algorithm makes a locally optimal choice, intending to find the global optimal solution. That is why it is called a Greedy Algorithm.

Question 7. b) While dealing with the negative edge weights, the Dijkstra’s algorithm is
not considered best. Explain the alternate suitable algorithm for single
source shortest path with an example. 

Answer. Dijkstra’s Algorithm: It is a graph searching algorithm that uses a Greedy Approach to find the shortest path from the source node to all other remaining nodes. It solves the single-source shortest path problem for a weighted graph. This algorithm keeps track of the weights of the edges for finding the path that minimizes the total distance.

Time Complexity: O(V + E*log(V)), when priority queue is used (where V are the nodes and E are the edges)

Limitations of Dijkstra’s Algorithm: For this algorithm to function properly:

The graph should be weighted and directed.
The weights should be non-negative.
Advantages of Dijkstra’s Algorithm:

It has a linear time complexity so it can be easily used for large problems.
It is useful in finding the shortest distance, so it is also used in google maps and calculating traffic.
Disadvantages of Dijkstra’s Algorithm:

It is unable to handle negative weights.
It follows a kind of blind approach so there is a wastage of time.

Question 8. a) Explain the principle of optimality with respect to binary search.

Answer. As we know that in binary search tree, the nodes in the left subtree have lesser value than the root node and the nodes in the right subtree have greater value than the root node.

We know the key values of each node in the tree, and we also know the frequencies of each node in terms of searching means how much time is required to search a node. The frequency and key-value determine the overall cost of searching a node. The cost of searching is a very important factor in various applications. The overall cost of searching a node should be less. The time required to search a node in BST is more than the balanced binary search tree as a balanced binary search tree contains a lesser number of levels than the BST. There is one way that can reduce the cost of a binary search tree is known as an optimal binary search tree.
If the keys are 10, 20, 30, 40, 50, 60, 70

https://static.javatpoint.com/ds/images/optimal-binary-search-tree.png

In the above tree, all the nodes on the left subtree are smaller than the value of the root node, and all the nodes on the right subtree are larger than the value of the root node. The maximum time required to search a node is equal to the minimum height of the tree, equal to logn.

Question 8. b) Find an optimal parenthesization of a matrix-chain product whose
sequence of dimensions is as follows:

Answer. Given a sequence of matrices, find the most efficient way to multiply these matrices together. The problem is not actually to perform the multiplications, but merely to decide in which order to perform the multiplications.
We have many options to multiply a chain of matrices because matrix multiplication is associative. In other words, no matter how we parenthesize the product, the result will be the same. For example, if we had four matrices A, B, C, and D, we would have: 


class MatrixChainMultiplication {
	// Matrix Ai has dimension p[i-1] x p[i] for i = 1..n
	static int MatrixChainOrder(int p[], int i, int j)
	{
		if (i == j)
			return 0;

		int min = Integer.MAX_VALUE;

		// place parenthesis at different places between
		// first and last matrix, recursively calculate
		// count of multiplications for each parenthesis
		// placement and return the minimum count
		for (int k = i; k < j; k++)
		{
			int count = MatrixChainOrder(p, i, k)
						+ MatrixChainOrder(p, k + 1, j)
						+ p[i - 1] * p[k] * p[j];

			if (count < min)
				min = count;
		}

		// Return minimum count
		return min;
	}

	// Driver code
	public static void main(String args[])
	{
		int arr[] = new int[] { 1, 2, 3, 4, 3 };
		int n = arr.length;

		System.out.println(
			"Minimum number of multiplications is "
			+ MatrixChainOrder(arr, 1, n - 1));
	}
}

